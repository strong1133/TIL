> # TIL - 2021-03-18

## 💡 시간복잡도

<hr/>

- 입력값과 문제를 해결하는 데 걸리는 시간과의 상관관계!
- 입력값이 2배로 늘어났을 때 문제를 해결하는데 걸리는 시간이 몇배 늘어날까 하는 개념

```python
  #예제 1
  for num in array:              # array 의 길이만큼 아래 연산이 실행
        for compare_num in array:  # array 의 길이만큼 아래 연산이 실행
            if num < compare_num:  # 비교 연산 1번 실행
                break
        else:
            return max_num
```

- 예제1 코드에서 for문은 array의 길이 n만큼 걸리고 for 안에 for문이 있으니 시간복잡도는 n\*n=N^2 이다.

```python
  for num in array:      # array 의 길이만큼 아래 연산이 실행
		    if num > max_num:  # 비교 연산 1번 실행
		        max_num = num  # 대입 연산 1번 실행
```

- 예제2 는 n만큼의 for문안에 비교, 대입이 한번씩 2n의 시간복잡도를 가진다.

> 비교

- N의 길이가 1일땐 N^2 =1 , 2N = 2 이므로 예제2가 오래걸리지만 N이 100, 1000으로 늘어나면 X2와 제곱은 엄청난 차이가 생긴다.

- 시간복잡도에서 중요한건 N에 대한 비례 값이다. 만약 어떤 코드에서 대해 시간 복잡도가 2N +3일경우 상수에 해당하는 +3은 신경쓰지 않아도 된다
  N^2에 비해 +3은 매우 작은 숫자이기 때문.
  <br/><br/>
  <br/><br/>

## 💡 공간복잡도

<hr/>

- 입력값과 문제를 해결하는데 걸리는 공간과의 상관관계
- 입력값이 2배로 늘어났을 때 문제를 해결하는 데 걸리는 공간은 몇배로 늘어나는지 보는 개념

<br/>

```python
  # 예제 1
  alphabet_array = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z"]
# -> 26 개의 공간을 사용합니다
    max_occurrence = 0 # 1개의 공간을 사용합니다
    max_alphabet = alphabet_array[0]   # 1개의 공간을 사용합니다.

    for alphabet in alphabet_array:
        occurrence = 0  # 1개의 공간을 사용합니다
```

- 저장하는 데이터의 양이 1개의 공간을 사용한다고 계산
- 예제1 에서는 array의 길이 26, 각 변수 3 해서 총 29만큼의 공간을 사용했다.

<br/>

```python
  # 예제 2
  lphabet_occurrence_list = [0] * 26 # -> 26 개의 공간을 사용합니다

    for char in string:
        if not char.isalpha():
            continue
        arr_index = ord(char) - ord('a')  # 1개의 공간을 사용합니다
        alphabet_occurrence_list[arr_index] += 1

    max_occurrence = 0                   # 1개의 공간을 사용합니다
    max_alphabet_index = 0               # 1개의 공간을 사용합니다
    for index in range(26):
        alphabet_occurrence = alphabet_occurrence_list[index] # 1개의 공간을 사용합니다
        if alphabet_occurrence > max_occurrence:
            max_occurrence = alphabet_occurrence
            max_alphabet_index = index
```

- 예제 2의 공간복잡도는 array의 길이 26,
  각 변수 4 해서 30이다.

> 비교

- 과연 둘중에 어떤 방법이 더 효율적일까?
- 크게 상관이 없음.. 그 이유는 두 공간복잡도는 상수다. 2n이나 n^2 인경우를 제외하고 일반 상수의 복잡도는 크게 신경쓰지 않는다. 따라서 대부분 알고리즘의 효율성을 따질때는 시간복잡도를 더 신경써야 한다.

<br/>
<br/>
<br/>

## 💡 점근 표기법

<hr/>

- 알고리즘의 성능을 수학적으로 표기하는 방법
- 알고리즘의 효율성을 평가하는 방법

> 종류

### 1. 빅오 표기법 O(N)

- 최악을 기준으로 효울성을 계산

### 2. 빅 오메가 표기법 Ω(N)

- 최선을 기준으로 효율성 계산

> 대부분의 알고리즘 분석은 빅오로 한다. 그이윤 최악의 경우를 더 고려해야 하기 때문
