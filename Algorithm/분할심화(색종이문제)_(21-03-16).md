> # TIL - 2021-03-15

## 💡 분할정복 백준 2630번 색종이 만들기
<hr/>

 > 문제분석

 <br/>
 <div style="text-align:center">
 <img src="https://www.acmicpc.net/upload/images/VHJpKWQDv.png" width="60%"></img>
 </div>
 <br/>

- n * n 의 사각형 배열 안에서 1과 0으로 이루어져 있는 사각형의 갯수를 찾는 문제
- 해당 그림에서 사격형의 갯수는 파란색 7개, 흰색 9개 이다.

> 예제 입력

    8 => 8*8크기의 정사각형 생성
    1 1 0 0 0 0 1 1  => 우리는 윗줄 부터 순차적으로 검색할것이다.
    1 1 0 0 0 0 1 1
    0 0 0 0 1 1 0 0
    0 0 0 0 1 1 0 0
    1 0 0 0 1 1 1 1
    0 1 0 0 1 1 1 1
    0 0 1 1 1 1 1 1
    0 0 1 1 1 1 1 1

> 분할정복의 개념

    1 1 0 0 0 0 1 1  # 최초 찾을 값은 (0,0) = 1
    1 1 0 0 0 0 1 1  # x좌표는 고정 시켜놓은 상태로 y값만 옆으로
    0 0 0 0 1 1 0 0  # (0,1) = 1 .. (0,2) = 0 => (0,2) = 0 이므로 1과는 다르다.
    0 0 0 0 1 1 0 0  
    1 0 0 0 1 1 1 1  
    0 1 0 0 1 1 1 1   
    0 0 1 1 1 1 1 1
    0 0 1 1 1 1 1 1
    # 일반적인 재귀 호출과 다른 점은 문제를 한 조각과 나머지 전체로 나누는 대신 
    # 분할 정복법은 '항상 문제를 반으로 나눈다.' 거의 같은 크기로 문제를 나눈다는 것.

- 이런 분할을 코드로 구현하려면 어떻게 해야할까?
- 우선 분할되기전에 x,y와 반복문에서 증가하는 최댓값을 어떻게 지정했는지 부터 생각해야한다.
- 분할 전 x,y가 n만큼 탐색하려면 +n까지 최대값이 지정 되어있어야 할 것이다.
     ```python
      # n=8일 경우
      # 분할 전 x는 
      for i in range(x,x+n):
        for j in range(y,y+n):
          #이경우 (x,y)가 0,0부터 시작한다는 가정하에
          # (x,y)는 (0,0)~(7,7) 까지 가능하다.
     ```
- 그렇다면 분할정복 개념을 사용한다면 8 => 4 => 2 => 1로 감소 해야하겠다.
- 위에서 (0,0) = 1 을 기준으로 (0,2) = 0 일때 반으로 나눠서 8 => 4로 해줘야
한다.
- x와 y는 항상 n까지 돌기 때문에 n을 반으로 나눈 몫을 써주면 되겠다.
- 그렇다면 함수에 인자 값을 받아 하는 값이 (x,y,n)이 될수 있으며 x,y는 좌표 값 n은 배열의 길이가 될수 있겠다.

> 함수 일부

```python
  n = int(input()) # 사각형의 크기

  # 사각형안을 채워주는 배열을 입력받는다.
  colorpaper = [list(map(int, input().split())) for _ in range(n)]  

  def cutting(x,y,n):
      check = colorpaper[x][y] # 함수 호출전에 만들어둔 배열에서 기준값을 뽑아준다. 
      for i in range(x, x+n): # x좌표 돌리기
        for j in range(y, y+n): # y좌표 돌리기
            if check != colorpaper[i][j]:  # 하나라도 같은 색이 아닐경우
                cutting(x, y, n//2)  # 1사분면

  cutting(0, 0, n)
```
  - 우선 n*n의 크기를 가지는 사각형을 만들기위해 n을 입력을 받는다.
  - n*n 사각형의 한줄 한줄을 채워줄 list를 입력을 받는다.
  - 함수를 만들어주는 부분이있고 
  - 바로 아래서 함수를 호출 한다. 함수를 호출할때  ` cutting(0, 0, n)` 
  - x=0, y=0, n=입력값
  - 호출되고 처음 들어온 최초의 함수는 x,y=0,0이기 때문에 
  - check = colorpaper[0][0] = 1이다.
  - x좌표 안에서 y좌표를 돌리며 colorpaper[i][j]의 값이 check와 일치 한지 판단한다.
  - x=0 [1 1 0 0 0 0 1 1] => 1, 1 넘고 0을 찾았을때 != 조건 충족으로
  - cutting(x, y, n//2) 첫번째 재귀 -> x,y는 4까지 돌면서 반쪽만 찾게된다.
   <br/> <br/>
  > 함수 전체
  
  ```python

    def cutting(x, y, n):
    global blue, white
    check = colorpaper[x][y]
    for i in range(x, x+n):
        for j in range(y, y+n):
            if check != colorpaper[i][j]:  # 하나라도 같은 색이 아닐경우
                cutting(x, y, n//2)  # 1사분면
                cutting(x, y+n//2, n//2)  # 2사분면
                cutting(x+n//2, y, n//2)  # 3사분면
                cutting(x+n//2, y+n//2, n//2)  # 4사분면
                return
    if check == 0:
        white += 1
        return
    else:
        blue += 1
        return
  ```
  - 재귀를 통과하고 for문을 통과 했다는 뜻은 현재 분할 탐색된 부분이 전부 일치 한다는 뜻이므로
  - 각 색상에 해당하는 변수에 +1을 해주고 return을 통해 재귀를 나온다.
    
        10
        01 
        이런 부분도 
        1 | 0
        --  --
        0 | 1   -> 이렇게 나눠 탐색하고 마친가지로 각각 색에 대한 +1를 하고 재귀를 나온다.
